# -*- coding: utf-8 -*-

# Copyright 2014-2015 by Christopher C. Little.
# This file is part of Abydos.
#
# Abydos is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Abydos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Abydos. If not, see <http://www.gnu.org/licenses/>.

"""abydos.compression

The compression module defines compression and compression-related functions
for use within Abydos, including implementations of the following:

    - arithmetic coding functions (ac_train, ac_encode, & ac_decode)
    - Burrows-Wheeler transform encoder/decoder (bwt_encode & bwt_decode)
    - Run-Length Encoding encoder/decoder (rle_encode & rle_decode)
"""

from __future__ import division, unicode_literals

from collections import Counter
from itertools import groupby

from ._compat import _long, _range, _unicode
from .util import Rational


def ac_train(text):
    r"""Generate a probability dict from the provided text.

    Text -> 0-order probability statistics as a dict

    This is based on Andrew Dalke's public domain implementation:
    http://code.activestate.com/recipes/306626/
    It has been ported to use the abydos.util.Rational class.

    :param text: The text data over which to calculate probability statistics.
        This must not contain the NUL (0x00) character because that's used to
        indicate the end of data.
    :returns: a probability dict
    :rtype: dict

    >>> ac_train('the quick brown fox jumped over the lazy dog')
    {'w': (29/45, 2/3), 'j': (37/45, 38/45), 'u': (16/45, 2/5),
    'l': (7/9, 4/5), 'd': (8/15, 26/45), 'o': (8/45, 4/15),
    'e': (4/15, 16/45), '\x00': (44/45, 1), 'q': (31/45, 32/45),
    'f': (8/9, 41/45), 'a': (43/45, 44/45), 'g': (13/15, 8/9),
    't': (2/5, 4/9), 'y': (3/5, 28/45), 'i': (38/45, 13/15),
    'h': (22/45, 8/15), 'c': (41/45, 14/15), ' ': (0, 8/45),
    'm': (34/45, 7/9), 'x': (28/45, 29/45), 'v': (2/3, 31/45),
    'z': (26/45, 3/5), 'b': (14/15, 43/45), 'k': (4/5, 37/45),
    'r': (4/9, 22/45), 'n': (11/15, 34/45), 'p': (32/45, 11/15)}
    """
    text = _unicode(text)
    if '\x00' in text:
        text = text.replace('\x00', ' ')
    counts = Counter(text)
    counts['\x00'] = 1
    tot_letters = sum(counts.values())

    tot = 0
    prob_range = {}
    prev = Rational(0)
    for char, count in sorted(counts.items(), key=lambda x: (x[1], x[0]),
                              reverse=True):
        follow = Rational(tot + count, tot_letters)
        prob_range[char] = (prev, follow)
        prev = follow
        tot = tot + count
    # assert tot == tot_letters

    return prob_range


def ac_encode(text, probs):
    """Encode a text using arithmetic coding with the provided probabilities.

    Text and the 0-order probability statistics -> longval, nbits

    The encoded number is rational(longval, 2**nbits)

    This is based on Andrew Dalke's public domain implementation:
    http://code.activestate.com/recipes/306626/
    It has been ported to use the abydos.util.Rational class.

    :param text: A string to encode
    :param probs: A probability statistics dictionary generated by ac_train
    :returns: The arithmetically coded text
    :rtype: tuple

    >>> pr = ac_train('the quick brown fox jumped over the lazy dog')
    >>> ac_encode('align', pr)
    (16720586181, 34)
    """
    text = _unicode(text)
    if '\x00' in text:
        text = text.replace('\x00', ' ')
    minval = Rational(0)
    maxval = Rational(1)
    for char in text + '\x00':
        prob_range = probs[char]
        delta = maxval - minval
        maxval = minval + prob_range[1] * delta
        minval = minval + prob_range[0] * delta

    # I tried without the /2 just to check.  Doesn't work.
    # Keep scaling up until the error range is >= 1.  That
    # gives me the minimum number of bits needed to resolve
    # down to the end-of-data character.
    delta = (maxval - minval) / 2
    nbits = _long(0)
    while delta < 1:
        nbits = nbits + 1
        delta <<= 1
    if nbits == 0:  # pragma: no cover
        return 0, 0
    else:
        # using -1 instead of /2
        avg = (maxval + minval) << (nbits-1)
    # Could return a rational instead ...
    return avg.p//avg.q, nbits  # the division truncation is deliberate


def ac_decode(longval, nbits, probs):
    """Decode the number to a string using the given statistics.

    This is based on Andrew Dalke's public domain implementation:
    http://code.activestate.com/recipes/306626/
    It has been ported to use the abydos.util.Rational class.

    :param longval: The first part of an encoded tuple from ac_encode
    :param nbits: The second part of an encoded tuple from ac_encode
    :param probs: A probability statistics dictionary generated by ac_train
    :returns: The arithmetically decoded text
    :rtype: str

    >>> pr = ac_train('the quick brown fox jumped over the lazy dog')
    >>> ac_decode(16720586181, 34, pr)
    'align'
    """
    val = Rational(longval, _long(1) << nbits)
    letters = []
    probs_items = [(char, minval, maxval) for (char, (minval, maxval))
                   in probs.items()]

    char = '\x00'
    while True:
        for (char, minval, maxval) in probs_items:  # noqa: B007
            if minval <= val < maxval:
                break

        if char == '\x00':
            break
        letters.append(char)
        delta = maxval - minval
        val = (val - minval)/delta
    return ''.join(letters)


def bwt_encode(word, terminator='\0'):
    r"""Return the Burrows-Wheeler transformed form of a word.

    The Burrows-Wheeler transform is an attempt at placing similar characters
    together to improve compression.
    Cf. https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform

    :param word: the word to transform using BWT
    :param terminator: a character to add to word to signal the end of the
        string
    :returns: word encoded by BWT
    :rtype: str

    >>> bwt_encode('align')
    'n\x00ilag'
    >>> bwt_encode('banana')
    'annb\x00aa'
    >>> bwt_encode('banana', '@')
    'annb@aa'
    """
    if word:
        if terminator in word:
            raise ValueError('Specified terminator, %s, already in word.'
                             .format(terminator if
                                     terminator != '\0' else '\\0'))
        else:
            word += terminator
            wordlist = sorted(word[i:] + word[:i] for i in _range(len(word)))
            return ''.join([w[-1] for w in wordlist])
    else:
        return terminator


def bwt_decode(code, terminator='\0'):
    r"""Return a word decoded from BWT form.

    The Burrows-Wheeler transform is an attempt at placing similar characters
    together to improve compression. This function reverses the transform.
    Cf. https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform

    :param code: the word to transform from BWT form
    :param terminator: a character added to word to signal the end of the
        string
    :returns: word decoded by BWT
    :rtype: str

    >>> bwt_decode('n\x00ilag')
    'align'
    >>> bwt_decode('annb\x00aa')
    'banana'
    >>> bwt_decode('annb@aa', '@')
    'banana'
    """
    if code:
        if terminator not in code:
            raise ValueError('Specified terminator, %s, absent from code.'
                             .format(terminator if
                                     terminator != '\0' else '\\0'))
        else:
            wordlist = [''] * len(code)
            for i in _range(len(code)):
                wordlist = sorted(code[i] + wordlist[i] for i in
                                  _range(len(code)))
            rows = [w for w in wordlist if w[-1] == terminator][0]
            return rows.rstrip(terminator)
    else:
        return ''


def rle_encode(text, use_bwt=True):
    r"""Perform encoding of run-length-encoding (RLE).

    Based on http://rosettacode.org/wiki/Run-length_encoding#Python

    Digits 0-9 cannot be in text.

    :param text: a text string to encode
    :param use_bwt: boolean indicating whether to perform BWT encoding before
        RLE encoding
    :returns: word decoded by BWT
    :rtype: str

    >>> rle_encode('align')
    'n\x00ilag'
    >>> rle_encode('align', use_bwt=False)
    'align'

    >>> rle_encode('banana')
    'annb\x00aa'
    >>> rle_encode('banana', use_bwt=False)
    'banana'

    >>> rle_encode('aaabaabababa')
    'ab\x00abbab5a'
    >>> rle_encode('aaabaabababa', False)
    '3abaabababa'
    """
    if use_bwt:
        text = bwt_encode(text)
    if text:
        text = ((len(list(g)), k) for k, g in groupby(text))
        text = ((str(n) + k if n > 2 else (k if n == 1 else 2*k)) for
                n, k in text)
    return ''.join(text)


def rle_decode(text, use_bwt=True):
    r"""Perform decoding of run-length-encoding (RLE).

    Based on http://rosettacode.org/wiki/Run-length_encoding#Python

    Digits 0-9 cannot have been in the original text.

    :param text: a text string to decode
    :param use_bwt: boolean indicating whether to perform BWT decoding after
        RLE decoding
    :returns: word decoded by BWT
    :rtype: str

    >>> rle_decode('n\x00ilag')
    'align'
    >>> rle_decode('align', use_bwt=False)
    'align'

    >>> rle_decode('annb\x00aa')
    'banana'
    >>> rle_decode('banana', use_bwt=False)
    'banana'

    >>> rle_decode('ab\x00abbab5a')
    'aaabaabababa'
    >>> rle_decode('3abaabababa', False)
    'aaabaabababa'
    """
    mult = ''
    decoded = []
    for letter in list(text):
        if not letter.isdigit():
            if mult:
                decoded.append(int(mult)*letter)
                mult = ''
            else:
                decoded.append(letter)
        else:
            mult += letter

    text = ''.join(decoded)
    if use_bwt:
        text = bwt_decode(text)
    return text
